# ============================================================================
# FLUENTD - VALUES.YAML COMPLET ȘI DETALIAT
# ============================================================================
# Configurație pentru agregare logs: Fluent Bit → Fluentd → Elasticsearch/etc
# Documentație: https://docs.fluentd.org/
# ============================================================================

# ----------------------------------------------------------------------------
# IMAGE CONFIGURATION
# ----------------------------------------------------------------------------
image:
  repository: fluent/fluentd-kubernetes-daemonset
  # Tag format: vX.XX-debianXX-1
  # Variante disponibile:
  #   - v1.17-debian-elasticsearch8-1 - Pentru Elasticsearch 8.x
  #   - v1.17-debian-elasticsearch7-1 - Pentru Elasticsearch 7.x
  #   - v1.17-debian-1 - Base image (fără output plugins preinstalate)
  # Verifică: https://hub.docker.com/r/fluent/fluentd-kubernetes-daemonset/tags
  tag: "v1.17-debian-1"
  pullPolicy: IfNotPresent

imagePullSecrets: []

# ----------------------------------------------------------------------------
# DEPLOYMENT TYPE
# ----------------------------------------------------------------------------
# Pentru Fluentd aggregator: Deployment (nu DaemonSet)
# DE CE: Fluentd primește de la Fluent Bit, nu citește direct din noduri
# Scalability: Poți avea multiple replici pentru high availability
kind: Deployment

# Număr de replici
# 1 = suficient pentru clustere mici (<50 noduri)
# 2-3 = pentru high availability
# 3+ = pentru clustere mari (>100 noduri) sau throughput mare
replicaCount: 1

# ----------------------------------------------------------------------------
# SERVICE ACCOUNT & RBAC
# ----------------------------------------------------------------------------
serviceAccount:
  create: true
  annotations: {}
  name: fluentd

# RBAC - mai puțin restrictiv decât Fluent Bit (nu citește din noduri)
rbac:
  create: true

# ----------------------------------------------------------------------------
# POD CONFIGURATION
# ----------------------------------------------------------------------------
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "24231"
  prometheus.io/path: "/metrics"

podLabels:
  app.kubernetes.io/name: fluentd
  app.kubernetes.io/component: log-aggregator

# Security Context - Fluentd poate rula ca non-root (mai sigur decât Fluent Bit)
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 999 # fluent user
  fsGroup: 999

securityContext:
  capabilities:
    drop: [ALL]
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  runAsNonRoot: true
  runAsUser: 999

# ----------------------------------------------------------------------------
# UPDATE STRATEGY
# ----------------------------------------------------------------------------
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1 # Câte pod-uri noi se pot crea simultan
    maxUnavailable: 0 # Zero downtime (întotdeauna cel puțin un pod active)

# ----------------------------------------------------------------------------
# RESOURCES
# ----------------------------------------------------------------------------
# Fluentd consumă mai mult decât Fluent Bit (procesare mai complexă)
# Ghid:
#   Small cluster (<20 nodes): 200m CPU, 512Mi RAM
#   Medium cluster (20-100 nodes): 500m CPU, 1Gi RAM
#   Large cluster (>100 nodes): 1 CPU, 2Gi RAM
resources:
  limits:
    cpu: 1000m # 1 CPU core
    memory: 1Gi # 1GB RAM - crește dacă vezi OOMKilled
  requests:
    cpu: 200m # CPU rezervat
    memory: 512Mi # RAM rezervat

# ----------------------------------------------------------------------------
# NODE SELECTION
# ----------------------------------------------------------------------------
nodeSelector: {} # Rulează pe orice nod worker

# Tolerations - de obicei nu e nevoie pe master pentru aggregator
tolerations: []

affinity:
  # Pod Anti-Affinity - distribuie replici pe noduri diferite (HA)
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - fluentd
          topologyKey: kubernetes.io/hostname

# ----------------------------------------------------------------------------
# VOLUMES & PERSISTENCE
# ----------------------------------------------------------------------------
# Fluentd are nevoie de volume pentru:
#   1. Buffer storage (dacă output e down)
#   2. Plugin cache
#   3. Configuration files

# Persistent Volume pentru buffer (RECOMANDAT pentru production)
persistence:
  enabled: true

  # Access mode
  # ReadWriteOnce = un singur nod (OK pentru Deployment cu 1 replica)
  # ReadWriteMany = multiple noduri (necesar pentru replicaCount > 1)
  accessMode: ReadWriteOnce

  # Size - depinde de volumul de logs și cât timp poate fi output-ul down
  # Formula: Size = Logs/sec × Seconds × Avg_log_size
  # Exemplu: 1000 logs/sec × 3600 sec (1h) × 1KB = 3.6GB
  # Recomandare: 10-50GB pentru safety margin
  size: 20Gi

  # Storage class - folosește ce ai disponibil în cluster
  # "" = default storage class
  # "standard" = HDD-based (mai ieftin)
  # "ssd" sau "fast" = SSD-based (mai rapid)
  storageClass: ""

# Extra volumes (pentru configurații custom, certificate, etc.)
extraVolumes: []
  # - name: custom-config
  #   configMap:
  #     name: fluentd-custom-config
  # - name: tls-certs
  #   secret:
  #     secretName: fluentd-tls

extraVolumeMounts: []
  # - name: custom-config
  #   mountPath: /fluentd/etc/custom
  # - name: tls-certs
  #   mountPath: /fluentd/certs

# ----------------------------------------------------------------------------
# SERVICE CONFIGURATION
# ----------------------------------------------------------------------------
service:
  # Type de service
  # ClusterIP = accesibil doar în cluster (RECOMANDAT)
  # NodePort = expune pe port pe fiecare nod (pentru debugging extern)
  # LoadBalancer = expune extern (dacă primești logs din afara clusterului)
  type: ClusterIP

  # Annotations pentru service (pentru cloud providers)
  annotations: {}
    # AWS ELB example:
    # service.beta.kubernetes.io/aws-load-balancer-type: nlb

  # Ports
  ports:
    # Forward port - pentru Fluent Bit
    - name: forward
      port: 24224
      targetPort: forward
      protocol: TCP

    # HTTP port - pentru metrics și health checks
    - name: http
      port: 24231
      targetPort: http
      protocol: TCP

    # Alte ports (decomentează la nevoie)
    # - name: syslog
    #   port: 5140
    #   targetPort: syslog
    #   protocol: TCP

# ----------------------------------------------------------------------------
# INGRESS (Optional - dacă vrei să expui extern)
# ----------------------------------------------------------------------------
ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts: []
  tls: []

# ----------------------------------------------------------------------------
# HEALTH CHECKS
# ----------------------------------------------------------------------------
livenessProbe:
  httpGet:
    path: /metrics
    port: http
  initialDelaySeconds: 30 # Fluentd pornește mai lent decât Fluent Bit
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /metrics
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

# ----------------------------------------------------------------------------
# ENVIRONMENT VARIABLES
# ----------------------------------------------------------------------------
env:
  # Fluentd system config
  - name: FLUENTD_CONF
    value: "fluent.conf"

  # Worker configuration
  # 0 = auto (număr de CPU cores)
  # N = număr specific de workers
  - name: FLUENTD_WORKERS
    value: "2"

  # Log level pentru Fluentd însuși
  # Opțiuni: trace, debug, info, warn, error, fatal
  - name: FLUENTD_LOG_LEVEL
    value: "info"

  # Pod info (pentru enrichment)
  - name: POD_NAME
    valueFrom:
      fieldRef:
        fieldPath: metadata.name
  - name: POD_NAMESPACE
    valueFrom:
      fieldRef:
        fieldPath: metadata.namespace

# envFrom - încarcă variabile din ConfigMap/Secret
envFrom: []
  # - configMapRef:
  #     name: fluentd-env

# ----------------------------------------------------------------------------
# METRICS & MONITORING
# ----------------------------------------------------------------------------
metrics:
  enabled: true

  # ServiceMonitor pentru Prometheus Operator
  serviceMonitor:
    enabled: false
    interval: 30s
    scrapeTimeout: 10s

# ============================================================================
# FLUENTD CONFIGURATION
# ============================================================================
# Documentație: https://docs.fluentd.org/configuration
# ============================================================================

# File configuration - configurația Fluentd în format Ruby-like
# Secțiuni: <system>, <source>, <filter>, <match>
fileConfigs:
  # --------------------------------------------------------------------------
  # 01_sources.conf - INPUT sources
  # --------------------------------------------------------------------------
  01_sources.conf: |-
    # ========================================================================
    # SOURCE: FORWARD - Primește de la Fluent Bit
    # ========================================================================
    # Protocol: Forward protocol (optimizat pentru Fluentd-to-Fluentd)
    # Port: 24224 (standard Fluentd)
    # Documentație: https://docs.fluentd.org/input/forward
    <source>
      @type forward
      
      # Port pe care ascultă (trebuie să matchuiască cu Fluent Bit output)
      port 24224
      
      # Bind address
      bind 0.0.0.0
      
      # Tag pentru toate mesajele primite
      # Dacă nu specifici, folosește tag-ul venit de la Fluent Bit
      # tag forward
      
      # ====================================================================
      # BUFFER & CHUNK SETTINGS
      # ====================================================================
      # Chunk size limit - mărimea maximă a unui chunk
      # Default: 8MB
      # Crește dacă primești throughput mare
      <transport tcp>
        # chunk_size_limit 16m
      </transport>
      
      # ====================================================================
      # SECURITY - TLS/Authentication (OPTIONAL)
      # ====================================================================
      # Decomentează pentru secure communication cu Fluent Bit
      # <transport tls>
      #   version TLS1_2
      #   ca_path /fluentd/certs/ca.crt
      #   cert_path /fluentd/certs/server.crt
      #   private_key_path /fluentd/certs/server.key
      #   client_cert_auth true
      # </transport>
      
      # Shared key authentication
      # <security>
      #   self_hostname fluentd
      #   shared_key my_secret_key
      # </security>
    </source>

    # ========================================================================
    # SOURCE: HTTP - Health checks și metrics
    # ========================================================================
    # Endpoint pentru Prometheus metrics și health checks
    <source>
      @type http
      port 24231
      bind 0.0.0.0
    </source>

    # ========================================================================
    # SOURCE: MONITOR_AGENT - Internal metrics
    # ========================================================================
    # Expune metrici despre buffer, retry, etc.
    <source>
      @type monitor_agent
      bind 0.0.0.0
      port 24220
    </source>

    # ========================================================================
    # SOURCES OPȚIONALE (decomentează la nevoie)
    # ========================================================================

    # SOURCE: SYSLOG - Primește syslog extern
    # <source>
    #   @type syslog
    #   port 5140
    #   bind 0.0.0.0
    #   tag syslog
    # </source>

    # SOURCE: TAIL - Citește din fișiere (dacă Fluentd rulează ca DaemonSet)
    # <source>
    #   @type tail
    #   path /var/log/containers/*.log
    #   pos_file /var/log/fluentd-containers.log.pos
    #   tag kubernetes.*
    #   <parse>
    #     @type json
    #     time_format %Y-%m-%dT%H:%M:%S.%NZ
    #   </parse>
    # </source>

  # --------------------------------------------------------------------------
  # 02_filters.conf - FILTERS pentru procesare
  # --------------------------------------------------------------------------
  02_filters.conf: |-
    # ========================================================================
    # FILTER: RECORD_TRANSFORMER - Adaugă/modifică fields
    # ========================================================================
    # Adaugă informații suplimentare în fiecare log record
    # Documentație: https://docs.fluentd.org/filter/record_transformer
    <filter kube.**>
      @type record_transformer
      enable_ruby true
      
      <record>
        # Adaugă timestamp când Fluentd a procesat log-ul
        fluentd_processed_at ${Time.now.iso8601}
        
        # Adaugă hostname Fluentd (pentru debugging)
        fluentd_hostname "#{Socket.gethostname}"
        
        # Adaugă identificator unic pentru tracking
        # log_id ${record["kubernetes"]["pod_name"]}-${Time.now.to_f}
      </record>
    </filter>

    # ========================================================================
    # FILTER: GREP - Include/Exclude logs bazat pe pattern
    # ========================================================================
    # Documentație: https://docs.fluentd.org/filter/grep

    # Exclude logs de la namespace-uri system (reduce noise)
    # <filter kube.**>
    #   @type grep
    #   <exclude>
    #     key $['kubernetes']['namespace_name']
    #     pattern /^(kube-system|kube-public|kube-node-lease)$/
    #   </exclude>
    # </filter>

    # Include doar ERROR logs (reduce volumul)
    # <filter kube.**>
    #   @type grep
    #   <regexp>
    #     key log
    #     pattern /ERROR|FATAL|CRITICAL/
    #   </regexp>
    # </filter>

    # ========================================================================
    # FILTER: PARSER - Parse logs (JSON, regex, etc.)
    # ========================================================================
    # Documentație: https://docs.fluentd.org/filter/parser

    # Parse JSON logs automat
    # <filter kube.**>
    #   @type parser
    #   key_name log
    #   reserve_data true
    #   remove_key_name_field false
    #   <parse>
    #     @type json
    #     time_type string
    #     time_format %Y-%m-%dT%H:%M:%S.%NZ
    #   </parse>
    # </filter>

    # ========================================================================
    # FILTER: PROMETHEUS - Export metrics
    # ========================================================================
    # Documentație: https://github.com/fluent/fluent-plugin-prometheus
    <filter kube.**>
      @type prometheus
      
      <metric>
        name fluentd_input_status_num_records_total
        type counter
        desc The total number of incoming records
        <labels>
          tag ${tag}
          hostname ${hostname}
        </labels>
      </metric>
    </filter>

  # --------------------------------------------------------------------------
  # 03_outputs.conf - OUTPUT destinations
  # --------------------------------------------------------------------------
  03_outputs.conf: |-
    # ========================================================================
    # OUTPUT: ELASTICSEARCH
    # ========================================================================
    # Trimite logs către Elasticsearch
    # Documentație: https://docs.fluentd.org/output/elasticsearch
    #<match kube.**>
      #@type elasticsearch
      
      # Elasticsearch hosts
      # Opțiuni:
      #   - Single host: elasticsearch.logging.svc.cluster.local
      #   - Multiple hosts: host1:9200,host2:9200,host3:9200
      #host elasticsearch.logging.svc.cluster.local
      #port 9200
      
      # Protocol: http sau https
      #cheme http
      
      # Index configuration
      # Logstash format: <prefix>-YYYY.MM.DD
      # Permite index rotation zilnică (ușor de șters logs vechi)
      #logstash_format true
      #logstash_prefix kubernetes
      
      # Index lifecycle - include timestamp în index
      #include_timestamp true
      
      # Type name (deprecated în ES 7+, dar necesar pentru compatibility)
      #type_name _doc
      
      # ====================================================================
      # AUTHENTICATION (OPTIONAL)
      # ====================================================================
      # Decomentează dacă Elasticsearch are authentication
      # user elastic
      # password changeme
      
      # Sau folosește environment variables (mai sigur)
      # user "#{ENV['ELASTICSEARCH_USER']}"
      # password "#{ENV['ELASTICSEARCH_PASSWORD']}"
      
      # ====================================================================
      # TLS/SSL (OPTIONAL)
      # ====================================================================
      # ssl_verify false  # Pentru development (NESIGUR în production!)
      # ca_file /fluentd/certs/ca.crt
      # client_cert /fluentd/certs/client.crt
      # client_key /fluentd/certs/client.key
      
      # ====================================================================
      # PERFORMANCE TUNING
      # ====================================================================
      # Reconnect on error
      #reconnect_on_error true
      #reload_on_failure true
      #reload_connections false
      
      # Request timeout
      #request_timeout 30s
      
      # ====================================================================
      # BUFFER CONFIGURATION - CRITIC pentru performance și reliability!
      # ====================================================================
      # Documentație: https://docs.fluentd.org/configuration/buffer-section
      #<buffer>
        # Buffer type
        # file = disk-based (persistent, RECOMANDAT)
        # memory = RAM-based (rapid dar pierde date la crash)
        #@type file
        
        # Path pentru buffer files (trebuie să existe volume mount)
        #path /var/log/fluentd-buffers/elasticsearch.buffer
        
        # ================================================================
        # CHUNK SETTINGS
        # ================================================================
        # Chunk = unitate de date trimisă către output
        
        # Chunk limit size - mărimea maximă a unui chunk
        # Default: 8MB
        # Crește pentru throughput mare (reduce requests)
        #chunk_limit_size 8M
        
        # Total limit size - maxim disk space pentru buffer
        # Calculează: chunk_limit_size × queue_limit_length
        # Exemplu: 8MB × 256 = 2GB
        # Crește dacă Elasticsearch e adesea down
        #total_limit_size 2G
        
        # ================================================================
        # FLUSH SETTINGS - Când se trimite chunk-ul
        # ================================================================
        # Flush mode - cum se decide când să flush
        # Opțiuni:
        #   - lazy: doar când chunk e plin (eficient dar latență mare)
        #   - interval: la interval regulat (balance)
        #   - immediate: instant (latență mică dar ineficient)
        #flush_mode interval
        
        # Flush interval - cât de des să flush
        # 5s = balance latență/eficiență
        # Scade pentru latență mică | Crește pentru eficiență
        #flush_interval 5s
        
        # Flush at shutdown - flush toate chunks la oprire
        #flush_at_shutdown true
        
        # Flush thread count - câte thread-uri pentru flush parallel
        # Crește pentru throughput mare
        #flush_thread_count 2
        
        # ================================================================
        # RETRY SETTINGS - Ce face dacă output-ul failuiește
        # ================================================================
        # Retry type
        # exponential_backoff = așteaptă progresiv mai mult (RECOMANDAT)
        # periodic = așteaptă fix interval
        #retry_type exponential_backoff
        
        # Retry wait - timp de așteptare inițial
        #retry_wait 1s
        
        # Retry max interval - timp maxim de așteptare între retry-uri
        #retry_max_interval 60s
        
        # Retry timeout - după cât timp să renunțe
        # none = retry forever (RECOMANDAT pentru logging)
        # 24h = renunță după 24h
        #retry_timeout none
        
        # Retry exponential backoff base
        #retry_exponential_backoff_base 2
        
        # Retry randomize - adaugă randomness pentru a evita thundering herd
        #retry_randomize true
        
        # ================================================================
        # OVERFLOW SETTINGS
        # ================================================================
        # Ce face când buffer-ul se umple complet
        # Opțiuni:
        #   - throw_exception: aruncă eroare (stop processing)
        #   - block: blochează input-ul (backpressure)
        #   - drop_oldest_chunk: șterge chunk-ul cel mai vechi
        #overflow_action block
      #</buffer>
    #</match>

    # ========================================================================
    # OUTPUT ALTERNATIVES (decomentează la nevoie)
    # ========================================================================

    # OUTPUT: S3 - Trimite către AWS S3 (arhivare long-term)
    # <match kube.**>
    #   @type s3
    #   
    #   aws_key_id YOUR_AWS_KEY_ID
    #   aws_sec_key YOUR_AWS_SECRET_KEY
    #   s3_bucket your-bucket-name
    #   s3_region us-east-1
    #   
    #   path logs/
    #   
    #   # Time slice pentru partitioning
    #   <buffer time>
    #     @type file
    #     path /var/log/fluentd-buffers/s3.buffer
    #     timekey 3600  # 1 hour
    #     timekey_wait 10m
    #     chunk_limit_size 256m
    #   </buffer>
    # </match>

    # OUTPUT: Kafka - Trimite către Apache Kafka
    # <match kube.**>
    #   @type kafka2
    #   
    #   brokers kafka:9092
    #   topic_key kubernetes
    #   default_topic logs
    #   
    #   <format>
    #     @type json
    #   </format>
    #   
    #   <buffer>
    #     @type file
    #     path /var/log/fluentd-buffers/kafka.buffer
    #   </buffer>
    # </match>

    # OUTPUT: HTTP - Trimite către HTTP endpoint generic
    # <match kube.**>
    #   @type http
    #   
    #   endpoint http://your-endpoint.com/logs
    #   http_method post
    #   
    #   <format>
    #     @type json
    #   </format>
    #   
    #   <buffer>
    #     @type file
    #     path /var/log/fluentd-buffers/http.buffer
    #   </buffer>
    # </match>

    # OUTPUT: CloudWatch Logs - AWS CloudWatch
    # <match kube.**>
    #   @type cloudwatch_logs
    #   
    #   region us-east-1
    #   log_group_name /kubernetes/logs
    #   log_stream_name ${tag}
    #   auto_create_stream true
    #   
    #   <buffer>
    #     @type file
    #     path /var/log/fluentd-buffers/cloudwatch.buffer
    #   </buffer>
    # </match>

    # OUTPUT: FILE - Scrie în fișiere locale (debugging/backup)
    # <match kube.**>
    #   @type file
    #   path /var/log/fluentd-output/${tag}
    #   append true
    #   
    #   <buffer tag,time>
    #     @type file
    #     path /var/log/fluentd-buffers/file.buffer
    #     timekey 3600  # 1 hour rotation
    #     timekey_wait 10m
    #   </buffer>
    #   
    #   <format>
    #     @type json
    #   </format>
    # </match>

    # OUTPUT: STDOUT - Print în console (debugging)
    <match kube.**>
      @type stdout
    </match>

  # --------------------------------------------------------------------------
  # 04_system.conf - System-level configuration
  # --------------------------------------------------------------------------
  04_system.conf: |-
    # ========================================================================
    # SYSTEM CONFIGURATION
    # ========================================================================
    # Documentație: https://docs.fluentd.org/deployment/system-config
    <system>
      # Workers - număr de procese worker
      # 0 = auto (număr de CPU cores)
      # N = număr specific
      # RECOMANDARE: 2-4 pentru production
      workers 2
      
      # Root directory pentru Fluentd
      root_dir /tmp/fluentd
      
      # Log level
      # trace, debug, info, warn, error, fatal
      log_level info
      
      # Suppress repeated log messages
      suppress_repeated_stacktrace true
      
      # Emit error log interval
      emit_error_log_interval 30s
      
      # Suppress config dump
      suppress_config_dump false
      
      # File permission (pentru buffer files)
      file_permission 0644
      dir_permission 0755
      
      # Process name
      process_name fluentd
    </system>

# ============================================================================
# NOTES & TROUBLESHOOTING
# ============================================================================
#
# 1. DEPLOYMENT:
#    helm repo add fluent https://fluent.github.io/helm-charts
#    helm install fluentd fluent/fluentd -n logging -f values.yaml
#
# 2. VERIFICARE:
#    kubectl get pods -n logging -l app.kubernetes.io/name=fluentd
#    kubectl logs -n logging -l app.kubernetes.io/name=fluentd -f
#
# 3. TESTARE CONNECTION de la Fluent Bit:
#    kubectl exec -n logging <fluent-bit-pod> -- \
#      echo '{"message":"test"}' | fluent-cat test --host fluentd.logging.svc.cluster.local
#
# 4. METRICS:
#    kubectl port-forward -n logging svc/fluentd 24231:24231
#    curl http://localhost:24231/metrics
#
# 5. BUFFER MONITORING:
#    kubectl exec -n logging <fluentd-pod> -- ls -lh /var/log/fluentd-buffers/
#
# 6. COMMON ISSUES:
#    - Connection refused: Verifică service name în Fluent Bit (fluentd.logging.svc.cluster.local)
#    - Buffer full: Crește total_limit_size sau verifică de ce Elasticsearch e down
#    - OOMKilled: Crește memory limits
#    - Slow processing: Crește workers sau flush_thread_count
#
# 7. ELASTICSEARCH VERIFICATION:
#    # Check indices
#    curl http://elasticsearch:9200/_cat/indices?v
#
#    # Check logs
#    curl http://elasticsearch:9200/kubernetes-*/_search?pretty
#
# 8. PERFORMANCE TUNING:
#    - Throughput mare: Crește chunk_limit_size, flush_thread_count, workers
#    - Latență mică: Scade flush_interval
#    - Memory constrained: Folosește buffer type file (nu memory)
#    - Disk constrained: Scade total_limit_size, chunk_limit_size
#
# ============================================================================
